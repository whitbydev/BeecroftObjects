<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLB Viewer — Three.js</title>
  <style>
    :root {
      --bg: #111;
      --panel: rgba(255,255,255,0.06);
      --accent: #00aaff;
      --text: #eee;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #container { width:100%; height:100vh; position:relative; overflow:hidden; }
    canvas { display:block; }

    .ui {
      position: absolute;
      left: 12px;
      top: 12px;
      background: var(--panel);
      padding: 10px;
      border-radius: 10px;
      backdrop-filter: blur(6px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.6);
      max-width: 420px;
      font-size: 14px;
    }
    .ui label { display:block; font-weight:600; margin-bottom:6px; color:#fff; }
    .ui input[type="text"] { width:100%; box-sizing:border-box; padding:6px 8px; border-radius:6px; border:1px solid rgba(255,255,255,0.08); background:transparent; color:var(--text); }
    .ui .row { display:flex; gap:8px; margin-top:8px; }
    .btn {
      appearance:none; border:0; padding:8px 10px; border-radius:6px; cursor:pointer; font-weight:600;
      background:var(--accent); color:#012; box-shadow: 0 6px 18px rgba(0,160,255,0.12);
    }
    .btn.secondary { background: transparent; border: 1px solid rgba(255,255,255,0.06); color:var(--text); }
    .status { margin-top:8px; font-size:13px; opacity:0.9; color:#ddd; }
    .hint { margin-top:6px; font-size:12px; color:#bbb; }
    .progress { height:6px; background: rgba(255,255,255,0.06); border-radius:6px; margin-top:8px; overflow:hidden; }
    .progress > i { display:block; height:100%; width:0%; background:linear-gradient(90deg, rgba(0,170,255,0.9), rgba(0,200,150,0.7)); transition:width 160ms linear; }
    .footer {
      position: absolute;
      right: 12px;
      bottom: 12px;
      color: #bbb;
      font-size: 13px;
      background: rgba(255,255,255,0.02);
      padding: 8px 10px;
      border-radius: 8px;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div id="container"></div>

  <div class="ui" id="ui">
    <label for="urlInput">Load .glb from URL</label>
    <input id="urlInput" type="text" placeholder="Paste .glb URL here (or leave default)" />
    <div class="row">
      <button class="btn" id="loadUrlBtn">Load URL</button>
      <button class="btn secondary" id="resetBtn">Reset Scene</button>
    </div>

    <label style="margin-top:10px;">Or upload a local .glb</label>
    <input id="fileInput" type="file" accept=".glb,.gltf" />

    <div class="status" id="status">Ready</div>
    <div class="progress" aria-hidden="true"><i id="progressBar"></i></div>
    <div class="hint">Tip: drag to orbit, scroll to zoom, right-drag or two-finger drag to pan.</div>
  </div>

  <div class="footer">Three.js GLB viewer</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/RGBELoader.js';

    // ---------- Config ----------
    const DEFAULT_MODEL_URL = 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/Duck/glTF-Binary/Duck.glb';
    // ----------------------------

    // UI refs
    const container = document.getElementById('container');
    const urlInput = document.getElementById('urlInput');
    const loadUrlBtn = document.getElementById('loadUrlBtn');
    const fileInput = document.getElementById('fileInput');
    const statusEl = document.getElementById('status');
    const progressBar = document.getElementById('progressBar');
    const resetBtn = document.getElementById('resetBtn');

    urlInput.value = DEFAULT_MODEL_URL;

    // Scene setup
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 1.6, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0.6, 0);
    controls.update();

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 1, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(2, 4, 2);
    dir.castShadow = true;
    scene.add(dir);

    const grid = new THREE.GridHelper(10, 20, 0x222222, 0x222222);
    grid.material.opacity = 0.08;
    grid.material.transparent = true;
    scene.add(grid);

    // Loaders
    const loader = new GLTFLoader();

    // Optional: a simple PMREM environ — commented out to avoid additional network calls.
    // If you want realistic reflections, load an HDR via RGBELoader and pmremGenerator.
    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    // Keep track of loaded model so we can dispose/reset
    let currentModel = null;

    function setStatus(msg, isError = false) {
      statusEl.textContent = msg;
      statusEl.style.color = isError ? '#ff8080' : '#ddd';
    }

    function setProgress(pct) {
      progressBar.style.width = Math.round(pct * 100) + '%';
    }

    function clearProgress() {
      progressBar.style.width = '0%';
    }

    function disposeModel(obj) {
      if (!obj) return;
      obj.traverse((child) => {
        if (child.isMesh) {
          child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose && mat.dispose());
            } else {
              child.material.dispose && child.material.dispose();
            }
          }
        }
      });
    }

    function resetScene() {
      if (currentModel) {
        scene.remove(currentModel);
        disposeModel(currentModel);
        currentModel = null;
      }
      setStatus('Scene reset. Ready.');
      clearProgress();
      controls.reset();
      camera.position.set(0, 1.6, 3);
      controls.target.set(0, 0.6, 0);
      controls.update();
    }

    async function loadGLBFromUrl(url) {
      resetScene();
      setStatus('Loading: ' + url);
      try {
        loader.manager.onProgress = (url_, itemsLoaded, itemsTotal) => {
          setProgress(itemsLoaded / itemsTotal);
        };
        loader.manager.onError = (e) => {
          console.error('Load error', e);
          setStatus('Error loading resources', true);
        };

        loader.load(
          url,
          (gltf) => {
            const root = gltf.scene || gltf.scenes[0];
            if (!root) {
              setStatus('No scene in that GLTF/GLB', true);
              return;
            }
            // optional: center and scale model
            const box = new THREE.Box3().setFromObject(root);
            const size = box.getSize(new THREE.Vector3()).length();
            const center = box.getCenter(new THREE.Vector3());

            const desiredSize = 1.5;
            const scale = desiredSize / size;
            root.position.x += (root.position.x - center.x) * scale;
            root.position.y += (root.position.y - center.y) * scale;
            root.position.z += (root.position.z - center.z) * scale;
            root.scale.multiplyScalar(scale);

            scene.add(root);
            currentModel = root;

            // Try to improve lighting if gltf has lights/cameras
            if (gltf.scene.userData && gltf.scene.userData.isGLTF) {
              // no-op
            }

            setStatus('Loaded successfully');
            clearProgress();
            // Fit camera to model
            fitCameraToObject(camera, root, controls);
          },
          (xhr) => {
            if (xhr.total) {
              setProgress(xhr.loaded / xhr.total);
            } else {
              setProgress(0.5); // indeterminate-ish
            }
          },
          (err) => {
            console.error('GLTF load error', err);
            setStatus('Failed to load model: ' + (err?.message || err), true);
            clearProgress();
          }
        );
      } catch (err) {
        console.error(err);
        setStatus('Error: ' + err.message, true);
      }
    }

    // Fit camera function borrowed & adapted for convenience
    function fitCameraToObject(camera, object, controls, offset = 1.25) {
      const boundingBox = new THREE.Box3();
      boundingBox.setFromObject(object);

      const center = boundingBox.getCenter(new THREE.Vector3());
      const size = boundingBox.getSize(new THREE.Vector3());

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));

      cameraZ *= offset; // zoom out a bit

      camera.position.z = center.z + cameraZ;
      camera.position.x = center.x;
      camera.position.y = center.y + Math.max(size.y * 0.5, 0.5);

      camera.near = 0.01;
      camera.far = cameraZ * 100;
      camera.updateProjectionMatrix();

      if (controls) {
        controls.target.copy(center);
        controls.update();
      }
    }

    // File input handler (local file)
    fileInput.addEventListener('change', (ev) => {
      const file = ev.target.files && ev.target.files[0];
      if (!file) return;
      if (!file.name.toLowerCase().endsWith('.glb') && !file.name.toLowerCase().endsWith('.gltf')) {
        setStatus('Please select a .glb or .gltf file', true);
        return;
      }
      const url = URL.createObjectURL(file);
      loadGLBFromUrl(url).then(() => {
        // release object URL after a delay (keep until model is used)
        setTimeout(() => URL.revokeObjectURL(url), 20000);
      });
    });

    // Load URL button
    loadUrlBtn.addEventListener('click', () => {
      const url = urlInput.value.trim();
      if (!url) {
        setStatus('Please paste a .glb URL first', true);
        return;
      }
      loadGLBFromUrl(url);
    });

    // Reset
    resetBtn.addEventListener('click', resetScene);

    // Resize handling
    window.addEventListener('resize', onWindowResize);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Basic render loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();

      // small idle rotation when not interacting
      if (!controls.dragging && currentModel) {
        currentModel.rotation.y += 0.05 * dt;
      }

      renderer.render(scene, camera);
    }

    // Start with default model loaded
    loadGLBFromUrl(DEFAULT_MODEL_URL);
    animate();

    // Clean up on page unload (helpful in SPA scenarios)
    window.addEventListener('unload', () => {
      resetScene();
      renderer.dispose();
      pmremGenerator.dispose();
    });
  </script>
</body>
</html>
