<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLB Viewer â€” Three.js</title>
  <style>
    :root {
      --bg: #111;
      --panel: rgba(255,255,255,0.06);
      --accent: #00aaff;
      --text: #eee;
    }
    html,body { height:100%; margin:0; background:var(--bg); color:var(--text); font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; }
    #container { width:100%; height:100vh; position:relative; overflow:hidden; }
    canvas { display:block; }

    .hint {
      position: absolute;
      left: 12px;
      bottom: 12px;
      font-size: 12px;
      color: #bbb;
      background: rgba(255,255,255,0.02);
      padding: 8px 10px;
      border-radius: 8px;
      backdrop-filter: blur(4px);
    }
    .footer {
      position: absolute;
      right: 12px;
      bottom: 12px;
      color: #bbb;
      font-size: 13px;
      background: rgba(255,255,255,0.02);
      padding: 8px 10px;
      border-radius: 8px;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div id="container"></div>
  <div class="hint">Tip: drag to orbit, scroll to zoom, right-drag or two-finger drag to pan.</div>
  <div class="footer">Three.js GLB viewer</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/GLTFLoader.js';
    import { RGBELoader } from 'https://unpkg.com/three@0.152.2/examples/jsm/loaders/RGBELoader.js';

    // --- Hardcoded URL configuration ---
    const HARDCODED_MODEL_URL = 'https://cdn.jsdelivr.net/gh/KhronosGroup/glTF-Sample-Models@master/2.0/DamagedHelmet/glTF-Binary/DamagedHelmet.glb';
    // ------------------------------------

    // Scene setup
    const container = document.getElementById('container');
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x222222);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
    camera.position.set(0, 1.6, 3);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);

    // Controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 0.6, 0);
    controls.update();

    // Lights
    const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
    hemi.position.set(0, 1, 0);
    scene.add(hemi);

    const dir = new THREE.DirectionalLight(0xffffff, 0.8);
    dir.position.set(2, 4, 2);
    dir.castShadow = true;
    scene.add(dir);

    const grid = new THREE.GridHelper(10, 20, 0x222222, 0x222222);
    grid.material.opacity = 0.08;
    grid.material.transparent = true;
    scene.add(grid);

    // Loaders
    const loader = new GLTFLoader();

    const pmremGenerator = new THREE.PMREMGenerator(renderer);
    pmremGenerator.compileEquirectangularShader();

    // Keep track of loaded model so we can dispose/reset
    let currentModel = null;

    function disposeModel(obj) {
      if (!obj) return;
      obj.traverse((child) => {
        if (child.isMesh) {
          child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose && mat.dispose());
            } else {
              child.material.dispose && child.material.dispose();
            }
          }
        }
      });
    }

    function resetScene() {
      if (currentModel) {
        scene.remove(currentModel);
        disposeModel(currentModel);
        currentModel = null;
      }
      controls.reset();
      camera.position.set(0, 1.6, 3);
      controls.target.set(0, 0.6, 0);
      controls.update();
    }

    async function loadGLBFromUrl(url) {
      resetScene();
      try {
        loader.load(
          url,
          (gltf) => {
            const root = gltf.scene || gltf.scenes[0];
            if (!root) {
              console.error('No scene in GLTF/GLB');
              return;
            }
            const box = new THREE.Box3().setFromObject(root);
            const size = box.getSize(new THREE.Vector3()).length();
            const center = box.getCenter(new THREE.Vector3());
            const desiredSize = 1.5;
            const scale = desiredSize / size;
            root.position.x += (root.position.x - center.x) * scale;
            root.position.y += (root.position.y - center.y) * scale;
            root.position.z += (root.position.z - center.z) * scale;
            root.scale.multiplyScalar(scale);

            scene.add(root);
            currentModel = root;
            fitCameraToObject(camera, root, controls);
          },
          (xhr) => {
            // progress updates are no longer shown in the UI
          },
          (err) => {
            console.error('Failed to load model:', err);
          }
        );
      } catch (err) {
        console.error('Error:', err.message);
      }
    }

    // Fit camera function
    function fitCameraToObject(camera, object, controls, offset = 1.25) {
      const boundingBox = new THREE.Box3();
      boundingBox.setFromObject(object);

      const center = boundingBox.getCenter(new THREE.Vector3());
      const size = boundingBox.getSize(new THREE.Vector3());

      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 * Math.tan(fov * 2));

      cameraZ *= offset;
      camera.position.z = center.z + cameraZ;
      camera.position.x = center.x;
      camera.position.y = center.y + Math.max(size.y * 0.5, 0.5);

      camera.near = 0.01;
      camera.far = cameraZ * 100;
      camera.updateProjectionMatrix();

      if (controls) {
        controls.target.copy(center);
        controls.update();
      }
    }

    // Resize handling
    window.addEventListener('resize', onWindowResize);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Basic render loop
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
